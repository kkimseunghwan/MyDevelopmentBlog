---
title: "DFS 깊이 우선 탐색 알고리즘"
date: "2025-05-02"
tags: ["Algorithm"]
slug: "DFS"
description: "DFS(Depth-First Search)는 그래프 탐색 알고리즘의 종류 중 하나입니다. 여기서 그래프는 여러 개의 점(정점)과 이 점들을 연결하는 선(간선)으로 이루어진 구조를 말합니다."
featured_image: "/images/DFS/20006c661e8280b697f7cac78f317263.png"
notion_last_edited_time: "2025-05-27T06:06:00.000Z"
---
![image](/images/DFS/20006c661e8280b697f7cac78f317263.png)

## DFS(깊이 우선 탐색) 이란?
- DFS(Depth-First Search)는 그래프 탐색 알고리즘의 종류 중 하나입니다. 
여기서 "그래프"는 여러 개의 점(정점)과 이 점들을 연결하는 선(간선)으로 이루어진 구조를 말합니다. 
**DFS**는 이 그래프에서 한 정점에서 시작해서, 갈 수 있는 곳까지 “**최대한 깊이”** 들어갔다가, 더 이상 갈 곳이 없으면 **뒤로 돌아와서** 다른 길을 찾아가는 방법입니다.
## DFS의 특징
1. **깊이 우선**
  - DFS는 가능한 한 **깊이**까지 탐색한 후, 더 이상 갈 수 없을 때 이전 단계로 돌아옵니다.
주어진 그래프에서 한 정점에서 출발하여 연결된 모든 정점을 방문할 때, 최대한 깊이 들어가서 탐색하는 방식입니다.
1. **재귀와 스택 사용**:
  - DFS는 재귀를 사용해 구현할 수 있으며, 이는 시스템의 **스택**을 활용한 것입니다.
  - 스택을 명시적으로 사용하여 반복문으로도 구현할 수 있습니다.
1. **경로 추적**:
  - DFS는 모든 경로를 탐색하므로, 특정 경로를 추적하거나, 경로를 찾는 문제에 자주 사용됩니다.
  - ex) 미로 탐색에서 경로를 찾는 경우
1. **방문 여부 확인**:
  - DFS에서는 각 정점을 한 번만 방문하기 위해 방문 여부를 기록하는 리스트나 배열을 사용합니다. 
이를 통해 무한 루프에 빠지지 않도록 합니다.
1. **백트래킹**:
  - DFS는 더 이상 진행할 수 없을 때, 이전 단계로 돌아가는 **백트래킹**의 기본 알고리즘입니다.
이 때문에, 퍼즐이나 조합 문제, 경로 탐색 문제에서 DFS가 자주 사용됩니다.
## DFS의 동작 방식
1. 시작 정점 선택: 출발점을 선택합니다.
1. 방문 기록: 방문한 정점을 기록해둡니다. (다시 그곳으로 돌아오지 않도록)
1. 인접 정점 방문: 현재 정점에서 이동할 수 있는 다른 정점들 중, 아직 방문하지 않은 곳이 있다면 그곳으로 이동합니다.
1. 더 이상 갈 곳이 없으면 돌아가기: 이동할 곳이 없다면 이전 정점으로 돌아갑니다.
1. 모든 정점 방문할 때까지 반복: 모든 정점을 방문할 때까지 이 과정을 반복합니다.
## 백준 1260 문제 코드 중 DFS
## DFS의 시간복잡도
- DFS의 시간 복잡도는 그래프의 정점 수 `V`와 간선 수 `E`에 따라 O(V + E) 입니다.
### DFS 개념 예시: 미로 탐색
당신은 미로 속에 있습니다. 이 미로에는 여러 갈림길이 있고, 당신은 출구를 찾으려 합니다. DFS는 “한 방향으로 갈 수 있을 만큼 최대한 가보고, 더 이상 갈 수 없으면 돌아와서 다른 길로 가본다"는 전략을 씁니다.
1. **한 방향으로 쭉 가기**: 출발점에서 시작해서 갈림길이 나오면 일단 한 방향으로 계속 갑니다.
1. **막다른 길이 나오면 돌아오기**: 만약 더 이상 갈 수 없는 막다른 길을 만나면, 방금 왔던 길로 돌아와서 다른 길을 찾습니다.
1. **다시 다른 길 찾기**: 돌아와서 다른 방향으로 갈 수 있다면 그쪽으로 또 쭉 가봅니다.
이런 식으로, 갈 수 있는 모든 경로를 탐색하다 보면 결국 출구를 찾게 됩니다.
### DFS를 어떻게 구현할까?

DFS를 구현하는 두 가지 방법이 있습니다: **재귀**를 사용하는 방법과 **스택**을 사용하는 방법입니다.

### 1. 재귀를 사용한 DFS

재귀 함수는 함수가 자기 자신을 호출하는 방식입니다. DFS에서는 재귀를 사용해 현재 위치에서 갈 수 있는 모든 곳을 다 가본 다음, 더 이상 갈 곳이 없으면 자동으로 이전 위치로 돌아옵니다.

```python
def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=' ')  # 방문한 정점을 출력

    for neighbor in graph[v]:
        if not visited[neighbor]:  # 아직 방문하지 않았다면
            dfs(graph, neighbor, visited)

```
- **`graph`**: 그래프를 인접 리스트로 표현한 것 (각 정점에서 갈 수 있는 정점들을 리스트로 나타냄).
- **`v`**: 현재 방문 중인 정점.
- **`visited`**: 이미 방문한 정점을 기록하는 리스트.
### 2. 스택을 사용한 DFS
스택을 사용해서 DFS를 반복문으로 구현할 수도 있습니다. 스택은 후입선출(LIFO, Last In, First Out)의 특징을 가지고 있습니다. 가장 나중에 들어온 정점이 가장 먼저 처리됩니다.

```python
def dfs_stack(graph, start):
    visited = [False] * len(graph)
    stack = [start]

    while stack:
        v = stack.pop()  # 스택에서 하나 꺼내서

        if not visited[v]:
            visited[v] = True
            print(v, end=' ')  # 방문한 정점을 출력

            for neighbor in reversed(graph[v]):  # 인접 정점을 스택에 추가
                if not visited[neighbor]:
                    stack.append(neighbor)

```
### DFS의 탐색 과정 예시
그래프가 다음과 같이 생겼다고 가정해봅시다.

```plain text
1 -- 2
|    |
3 -- 4

```
- 1번 정점에서 DFS를 시작합니다.
- **재귀 방식**: 1 → 2 → 4 → 3 이런 순서로 방문합니다.
- **스택 방식**: 1 → 2 → 4 → 3 이런 순서로 방문합니다.
### DFS와 BFS의 차이점
- **DFS**는 **깊이**를 우선으로 탐색하며, 먼저 들어간 경로를 끝까지 탐색하려고 합니다.
- **BFS**는 **너비**를 우선으로 탐색하며, 가까운 정점들부터 모두 탐색한 후 다음 단계로 넘어갑니다.